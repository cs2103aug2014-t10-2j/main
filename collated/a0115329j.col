//@author: a0115329j



	/**
	 * origin: D:\everything\eclipseworkspace\ZombieTask\main\src\tests\ZombieTaskInterpreterAtd.java
	 */

 * 
 */
public class ZombieTaskInterpreterAtd {

	private final ByteArrayOutputStream outContent = new ByteArrayOutputStream();

	@Before
	public void setUpStreams() {
		// System.setOut(new PrintStream(outContent));
	}

	@Before
	public void deleteFile() {
		new File("ZombieTest").delete();
	}

	@After
	public void cleanUpStreams() {
		System.setOut(null);
	}

	@Test
	public void testAdd() throws Exception {

		// Test 1: Correct methods called by ZombieTask
		ZombieTask.testCommand("have lunch");
		String commandCalled = ZombieTaskCommandHandler.getCommandCalled();
		assertEquals(Command.ADD, commandCalled);
		
		ZombieTask.testCommand("view agenda");
		commandCalled = ZombieTaskCommandHandler.getCommandCalled();
		assertEquals(Command.VIEW, commandCalled);
		
		ZombieTask.testCommand("delete f0");
		commandCalled = ZombieTaskCommandHandler.getCommandCalled();
		assertEquals(Command.DELETE, commandCalled);
		
		ZombieTask.testCommand("add have lunch 2pm");
		commandCalled = ZombieTaskCommandHandler.getCommandCalled();
		assertEquals(Command.ADD, commandCalled);
		
		ZombieTask.testCommand("update d0 have lunch 2pm >canteen");
		commandCalled = ZombieTaskCommandHandler.getCommandCalled();
		assertEquals(Command.UPDATE, commandCalled);
		
		ZombieTask.testCommand("undo");
		commandCalled = ZombieTaskCommandHandler.getCommandCalled();
		assertEquals(Command.UNDO, commandCalled);
		
		ZombieTask.testCommand("redo");
		commandCalled = ZombieTaskCommandHandler.getCommandCalled();
		assertEquals(Command.REDO, commandCalled);
		
		ZombieTask.testCommand("help");
		commandCalled = ZombieTaskCommandHandler.getCommandCalled();
		assertEquals(Command.HELP, commandCalled);
		
		ZombieTask.testCommand("search-name x");
		commandCalled = ZombieTaskCommandHandler.getCommandCalled();
		assertEquals(Command.SEARCH_NAME, commandCalled);
		
		ZombieTask.testCommand("search-time 2:00pm to 4:00pm");
		commandCalled = ZombieTaskCommandHandler.getCommandCalled();
		assertEquals(Command.SEARCH_TIME, commandCalled);

	}
}

	// End of segment: D:\everything\eclipseworkspace\ZombieTask\main\src\tests\ZombieTaskInterpreterAtd.java





	/**
	 * origin: D:\everything\eclipseworkspace\ZombieTask\main\src\tests\InterpreterAtd.java
	 */

 * 
 */
public class InterpreterAtd {

	@Test
	public void testGetCommandType() {
		// Test 1: Basic function
		assertEquals(Command.ADD, Interpreter.getCommandType("add"));
		assertEquals(Command.ADD, Interpreter.getCommandType("breakfast"));
		assertEquals(Command.DELETE, Interpreter.getCommandType("delete"));
		assertEquals(Command.UNDO, Interpreter.getCommandType("undo"));
		assertEquals(Command.REDO, Interpreter.getCommandType("redo"));
		assertEquals(Command.UPDATE, Interpreter.getCommandType("update"));
		assertEquals(Command.HELP, Interpreter.getCommandType("help"));
		assertEquals(Command.EXIT, Interpreter.getCommandType("exit"));
	}

	@Test
	public void testGetCommandAddFloating() throws Exception {
		// to test parsing of floating tasks

		// Test 1: Basic test
		Command command = Interpreter.getCommand("add #food eat "
				+ "something #impt @restaurant");
		assertEquals(Command.ADD, command.getCommandType());
		CommandAdd add = (CommandAdd) command;

		testTags(add.getTags(), "#food #impt");
		assertEquals("@restaurant", add.getLocation());

		assertNull(add.getStartDate());
		assertNull(add.getEndDate());

		assertEquals("eat something", add.getTaskName());
		assertEquals("add #food eat something #impt @restaurant",
				add.getUserInput());

		// Test 2: case-insensitivity (of command) and white space
		// case sensitivity of task name, tags and location
		command = Interpreter
				.getCommand("   Add    \n#Food @Canteen Eat #impt");
		assertEquals(Command.ADD, command.getCommandType());
		add = (CommandAdd) command;

		assertNull(add.getStartDate());
		assertNull(add.getEndDate());

		testTags(add.getTags(), "#Food #impt");
		assertEquals("@Canteen", add.getLocation());

		assertEquals("Eat", add.getTaskName());
		assertEquals("   Add    \n#Food @Canteen Eat #impt", add.getUserInput());

		// Test 3: unspecified command
		command = Interpreter.getCommand("Lunch #impt #food");
		assertEquals(Command.ADD, command.getCommandType());
		add = (CommandAdd) command;

		assertNull(add.getStartDate());
		assertNull(add.getEndDate());

		assertEquals("Lunch", add.getTaskName());
		assertEquals("Lunch #impt #food", add.getUserInput());

		// Test 4: escape character
		command = Interpreter.getCommand("have \"22\" bananas #fruit #dessert");
		assertEquals(Command.ADD, command.getCommandType());
		add = (CommandAdd) command;

		assertNull(add.getStartDate());
		assertNull(add.getEndDate());

		testTags(add.getTags(), "#fruit #dessert");
		assertEquals("have 22 bananas", add.getTaskName());
		assertEquals("have \"22\" bananas #fruit #dessert", add.getUserInput());

		command = Interpreter.getCommand("read \"today's\" papers");
		assertEquals(Command.ADD, command.getCommandType());
		add = (CommandAdd) command;

		assertNull(add.getStartDate());
		assertNull(add.getEndDate());

		assertEquals("read today's papers", add.getTaskName());
		assertEquals("read \"today's\" papers", add.getUserInput());

	}

	@Test
	public void testGetCommandAddDeadline() throws Exception {
		// to test parsing of deadline tasks

		// Test 1: Basic test
		Command command = Interpreter.getCommand("add today #food eat "
				+ "something #impt @home");
		assertEquals(Command.ADD, command.getCommandType());
		CommandAdd add = (CommandAdd) command;

		Calendar today = Calendar.getInstance();
		assertNull(add.getStartDate());
		testDate(add.getEndDate(), today);

		testTags(add.getTags(), "#food #impt");
		assertEquals("@home", add.getLocation());

		assertEquals("eat something", add.getTaskName());
		assertEquals("add today #food eat something #impt @home",
				add.getUserInput());

		// Test 2: case-insensitivity and white space
		command = Interpreter.getCommand("   Add   30 Sep \n#food Eat #impt");
		assertEquals(Command.ADD, command.getCommandType());
		add = (CommandAdd) command;

		assertNull(add.getStartDate());
		testDate(add.getEndDate(), today.get(Calendar.YEAR), 8, 30,
				today.get(Calendar.HOUR_OF_DAY), today.get(Calendar.MINUTE),
				today.get(Calendar.SECOND));

		testTags(add.getTags(), "#food #impt");
		assertEquals("Eat", add.getTaskName());
		assertEquals("   Add   30 Sep \n#food Eat #impt", add.getUserInput());

		// Test 3: unspecified command
		command = Interpreter.getCommand("30 Sep Lunch @home #impt #food");
		assertEquals(Command.ADD, command.getCommandType());
		add = (CommandAdd) command;

		assertNull(add.getStartDate());
		testDate(add.getEndDate(), 2014, 8, 30,
				today.get(Calendar.HOUR_OF_DAY), today.get(Calendar.MINUTE),
				today.get(Calendar.SECOND));

		testTags(add.getTags(), "#impt #food");
		assertEquals("@home", add.getLocation());
		assertEquals("Lunch", add.getTaskName());
		assertEquals("30 Sep Lunch @home #impt #food", add.getUserInput());

		// Test 4: escape character
		command = Interpreter
				.getCommand("have \"three\" bananas @sch tomorrow #fruit");
		assertEquals(Command.ADD, command.getCommandType());
		add = (CommandAdd) command;

		Calendar tomorrow = Calendar.getInstance();
		tomorrow.add(Calendar.DATE, 1);
		tomorrow.setTime(tomorrow.getTime());

		assertNull(add.getStartDate());
		testDate(add.getEndDate(), tomorrow);

		testTags(add.getTags(), "#fruit");
		assertEquals("@sch", add.getLocation());

		assertEquals("have three bananas", add.getTaskName());
		assertEquals("have \"three\" bananas @sch tomorrow #fruit",
				add.getUserInput());

		command = Interpreter.getCommand("read \"Friday's\" papers tomorrow");
		assertEquals(Command.ADD, command.getCommandType());
		add = (CommandAdd) command;

		assertNull(add.getStartDate());
		testDate(add.getEndDate(), tomorrow);

		assertEquals("read Friday's papers", add.getTaskName());
		assertEquals("read \"Friday's\" papers tomorrow", add.getUserInput());

	}

	@Test
	public void testGetCommandAddTimed() throws Exception {
		// to test parsing of timed tasks

		// Test 1: Basic test
		Command command = Interpreter
				.getCommand("add today 1pm to 2pm #food eat "
						+ "something #impt @sch");
		assertEquals(Command.ADD, command.getCommandType());
		CommandAdd add = (CommandAdd) command;
		Calendar today = Calendar.getInstance();
		testDate(add.getStartDate(), today.get(Calendar.YEAR),
				today.get(Calendar.MONTH), today.get(Calendar.DATE), 13, 0, 0);
		testDate(add.getEndDate(), today.get(Calendar.YEAR),
				today.get(Calendar.MONTH), today.get(Calendar.DATE), 14, 0, 0);

		testTags(add.getTags(), "#food #impt");
		assertEquals("eat something", add.getTaskName());
		assertEquals("@sch", add.getLocation());
		assertEquals("add today 1pm to 2pm #food eat something #impt @sch",
				add.getUserInput());

		// Test 2: case-insensitivity and white space
		command = Interpreter
				.getCommand("   Add  30 Sep to 1 nov @house \n#food Eat");
		assertEquals(Command.ADD, command.getCommandType());
		add = (CommandAdd) command;

		testDate(add.getStartDate(), today.get(Calendar.YEAR), 8, 30,
				today.get(Calendar.HOUR_OF_DAY), today.get(Calendar.MINUTE),
				today.get(Calendar.SECOND));
		testDate(add.getEndDate(), today.get(Calendar.YEAR), 10, 1,
				today.get(Calendar.HOUR_OF_DAY), today.get(Calendar.MINUTE),
				today.get(Calendar.SECOND));

		testTags(add.getTags(), "#food");
		assertEquals("@house", add.getLocation());
		assertEquals("Eat", add.getTaskName());
		assertEquals("   Add  30 Sep to 1 nov @house \n#food Eat",
				add.getUserInput());

		// Test 3: unspecified command
		command = Interpreter
				.getCommand("30 Sep 1:30 to 2 @home Lunch #impt #food");
		assertEquals(Command.ADD, command.getCommandType());
		add = (CommandAdd) command;
		testDate(add.getStartDate(), 2014, 8, 30, 1, 30, 0);
		testDate(add.getEndDate(), 2014, 8, 30, 2, 0, 0);
		testTags(add.getTags(), "#impt #food");
		assertEquals("@home", add.getLocation());
		assertEquals("Lunch", add.getTaskName());

		// Test 4: escape character
		command = Interpreter
				.getCommand("have \"three\" bananas tomorrow 5pm to 6pm");
		assertEquals(Command.ADD, command.getCommandType());
		add = (CommandAdd) command;

		Calendar tomorrow = Calendar.getInstance();
		tomorrow.add(Calendar.DATE, 1);
		tomorrow.setTime(tomorrow.getTime());
		testDate(add.getStartDate(), tomorrow.get(Calendar.YEAR),
				tomorrow.get(Calendar.MONTH), tomorrow.get(Calendar.DATE), 17,
				0, 0);
		testDate(add.getEndDate(), tomorrow.get(Calendar.YEAR),
				tomorrow.get(Calendar.MONTH), tomorrow.get(Calendar.DATE), 18,
				0, 0);

		assertEquals("have three bananas", add.getTaskName());
		assertEquals("have \"three\" bananas tomorrow 5pm to 6pm",
				add.getUserInput());

		// Test 5: automatically order dates
		command = Interpreter
				.getCommand("drink \"three glasses 8D\" tomorrow 6pm to 5pm");
		assertEquals(Command.ADD, command.getCommandType());
		add = (CommandAdd) command;

		testDate(add.getStartDate(), tomorrow.get(Calendar.YEAR),
				tomorrow.get(Calendar.MONTH), tomorrow.get(Calendar.DATE), 17,
				0, 0);
		testDate(add.getEndDate(), tomorrow.get(Calendar.YEAR),
				tomorrow.get(Calendar.MONTH), tomorrow.get(Calendar.DATE), 18,
				0, 0);

		assertEquals("drink three glasses 8D", add.getTaskName());
		assertEquals("drink \"three glasses 8D\" tomorrow 6pm to 5pm",
				add.getUserInput());

	}

	/**
	 * Helper method to check dates
	 * 
	 * @param date date expected
	 * @param year year of the date expected
	 * @param month month of the date expected
	 * @param day day of the date expected
	 * @param hour hour of the time expected
	 * @param minute minute of the time expected
	 * @param second second of the time expected
	 */
	public static void testDate(Calendar date, int year, int month, int day,
			int hour, int minute, int second) {
		assertEquals(year, date.get(Calendar.YEAR));
		assertEquals(month, date.get(Calendar.MONTH));
		assertEquals(day, date.get(Calendar.DATE));
		assertEquals(hour, date.get(Calendar.HOUR_OF_DAY));
		assertEquals(minute, date.get(Calendar.MINUTE));
		assertEquals(second, date.get(Calendar.SECOND));
	}

	/**
	 * Helper method to check dates
	 * 
	 * @param date date to check
	 * @param dateExpected date expected
	 */
	public static void testDate(Calendar date, Calendar dateExpected) {
		assertEquals(dateExpected.get(Calendar.YEAR), date.get(Calendar.YEAR));
		assertEquals(dateExpected.get(Calendar.MONTH), date.get(Calendar.MONTH));
		assertEquals(dateExpected.get(Calendar.DATE), date.get(Calendar.DATE));
		assertEquals(dateExpected.get(Calendar.HOUR_OF_DAY),
				date.get(Calendar.HOUR_OF_DAY));
		assertEquals(dateExpected.get(Calendar.MINUTE),
				date.get(Calendar.MINUTE));
		assertEquals(dateExpected.get(Calendar.SECOND),
				date.get(Calendar.SECOND));
	}

	/**
	 * Helper method to test tags
	 * 
	 * @param tags tags obtained from test
	 * @param tagsExpected expected output of test, separated by spaces
	 */
	public static void testTags(ArrayList<String> tags, String tagsExpected) {
		String[] tagTokens = tagsExpected.split(" ");
		assertEquals(Arrays.asList(tagTokens), tags);
	}

	@Test
	public void testGetCommandDelete() throws Exception {
		// Test 1: Basic function
		Command command = Interpreter.getCommand("delete d5 f2");
		assertEquals(Command.DELETE, command.getCommandType());
		CommandDelete delete = (CommandDelete) command;
		assertEquals("d5", delete.getLineCode().get(0));
		assertEquals("f2", delete.getLineCode().get(1));
		assertEquals("delete d5 f2", delete.getUserInput());

		// Test 2: case-insensitivity
		command = Interpreter.getCommand("DELETE F5");
		assertEquals(Command.DELETE, command.getCommandType());
		delete = (CommandDelete) command;
		assertEquals("f5", delete.getLineCode().get(0));
		assertEquals("DELETE F5", delete.getUserInput());

		// Test 3: delete range
		command = Interpreter.getCommand("delete t5-8");
		assertEquals(Command.DELETE, command.getCommandType());
		delete = (CommandDelete) command;
		assertEquals("t5", delete.getLineCode().get(0));
		assertEquals("t6", delete.getLineCode().get(1));
		assertEquals("t7", delete.getLineCode().get(2));
		assertEquals("t8", delete.getLineCode().get(3));
		assertEquals("delete t5-8", delete.getUserInput());

		// reverse order
		command = Interpreter.getCommand("delete f4-1");
		assertEquals(Command.DELETE, command.getCommandType());
		delete = (CommandDelete) command;
		assertEquals("f1", delete.getLineCode().get(0));
		assertEquals("f2", delete.getLineCode().get(1));
		assertEquals("f3", delete.getLineCode().get(2));
		assertEquals("f4", delete.getLineCode().get(3));
		assertEquals("delete f4-1", delete.getUserInput());

		// Test 4: delete multiple
		command = Interpreter.getCommand("delete t4 t1");
		assertEquals(Command.DELETE, command.getCommandType());
		delete = (CommandDelete) command;
		assertEquals("t4", delete.getLineCode().get(0));
		assertEquals("t1", delete.getLineCode().get(1));
		assertEquals("delete t4 t1", delete.getUserInput());

		// Test 4: invalid arguments
		command = Interpreter.getCommand("delete me");
		assertEquals(Command.DELETE, command.getCommandType());
		delete = (CommandDelete) command;
		assertNull(delete.getLineCode());
		assertTrue(delete.hasMissingArgs());
		assertEquals("delete me", delete.getUserInput());

		command = Interpreter.getCommand("delete");
		assertEquals(Command.DELETE, command.getCommandType());
		delete = (CommandDelete) command;
		assertNull(delete.getLineCode());
		assertTrue(delete.hasMissingArgs());
		assertEquals("delete", delete.getUserInput());
	}
	
	@Test
	public void testGetCommandDone() throws Exception {
		// Test 1: Basic function
		Command command = Interpreter.getCommand("done d5 f2");
		assertEquals(Command.DONE, command.getCommandType());
		CommandDone done = (CommandDone) command;
		assertEquals("d5", done.getLineCode().get(0));
		assertEquals("f2", done.getLineCode().get(1));
		assertEquals("done d5 f2", done.getUserInput());

		// Test 2: case-insensitivity
		command = Interpreter.getCommand("DONE F5");
		assertEquals(Command.DONE, command.getCommandType());
		done = (CommandDone) command;
		assertEquals("f5", done.getLineCode().get(0));
		assertEquals("DONE F5", done.getUserInput());

		// Test 3: done range
		command = Interpreter.getCommand("done t5-8");
		assertEquals(Command.DONE, command.getCommandType());
		done = (CommandDone) command;
		assertEquals("t5", done.getLineCode().get(0));
		assertEquals("t6", done.getLineCode().get(1));
		assertEquals("t7", done.getLineCode().get(2));
		assertEquals("t8", done.getLineCode().get(3));
		assertEquals("done t5-8", done.getUserInput());

		// reverse order
		command = Interpreter.getCommand("done f4-1");
		assertEquals(Command.DONE, command.getCommandType());
		done = (CommandDone) command;
		assertEquals("f1", done.getLineCode().get(0));
		assertEquals("f2", done.getLineCode().get(1));
		assertEquals("f3", done.getLineCode().get(2));
		assertEquals("f4", done.getLineCode().get(3));
		assertEquals("done f4-1", done.getUserInput());

		// Test 4: done multiple
		command = Interpreter.getCommand("done t4 t1");
		assertEquals(Command.DONE, command.getCommandType());
		done = (CommandDone) command;
		assertEquals("t4", done.getLineCode().get(0));
		assertEquals("t1", done.getLineCode().get(1));
		assertEquals("done t4 t1", done.getUserInput());

		// Test 4: invalid arguments
		command = Interpreter.getCommand("done me");
		assertEquals(Command.DONE, command.getCommandType());
		done = (CommandDone) command;
		assertNull(done.getLineCode());
		assertTrue(done.hasMissingArgs());
		assertEquals("done me", done.getUserInput());

		command = Interpreter.getCommand("done");
		assertEquals(Command.DONE, command.getCommandType());
		done = (CommandDone) command;
		assertNull(done.getLineCode());
		assertTrue(done.hasMissingArgs());
		assertEquals("done", done.getUserInput());
	}

	@Test
	public void testGetCommandUpdate() throws Exception {
		// Test 1: Basic function
		Command command = Interpreter
				.getCommand("update d2 @sch go lunch sep 21 #food");
		assertEquals(Command.UPDATE, command.getCommandType());
		CommandUpdate update = (CommandUpdate) command;
		assertEquals("d2", update.getLineCode());

		CommandAdd updatedTask = update.getUpdatedTask();
		testTags(updatedTask.getTags(), "#food");
		assertEquals("@sch", updatedTask.getLocation());
		assertEquals("go lunch", updatedTask.getTaskName());
		Calendar today = Calendar.getInstance();
		testDate(updatedTask.getEndDate(), today.get(Calendar.YEAR), 8, 21,
				today.get(Calendar.HOUR_OF_DAY), today.get(Calendar.MINUTE),
				today.get(Calendar.SECOND));
		assertEquals("update d2 @sch go lunch sep 21 #food",
				update.getUserInput());

		// Test 2: Update by field
		// location
		command = Interpreter.getCommand("update d2 @sch");
		update = (CommandUpdate) command;
		updatedTask = update.getUpdatedTask();
		assertNull(updatedTask.getTaskName());
		assertTrue(updatedTask.getTags().isEmpty());
		assertEquals("@sch", updatedTask.getLocation());
		assertNull(updatedTask.getStartDate());
		assertNull(updatedTask.getEndDate());

		// task name
		command = Interpreter.getCommand("update d2 have lunch");
		update = (CommandUpdate) command;
		updatedTask = update.getUpdatedTask();
		assertEquals("have lunch", updatedTask.getTaskName());
		assertTrue(updatedTask.getTags().isEmpty());
		assertNull(updatedTask.getLocation());
		assertNull(updatedTask.getStartDate());
		assertNull(updatedTask.getEndDate());

		// time
		command = Interpreter.getCommand("update d2 9/11 2pm");
		update = (CommandUpdate) command;
		updatedTask = update.getUpdatedTask();
		assertNull(updatedTask.getTaskName());
		assertTrue(updatedTask.getTags().isEmpty());
		assertNull(updatedTask.getLocation());
		assertNull(updatedTask.getStartDate());
		testDate(updatedTask.getEndDate(), today.get(Calendar.YEAR), 8, 11, 14,
				0, 0);

		// tag
		command = Interpreter.getCommand("update d2 #haha");
		update = (CommandUpdate) command;
		updatedTask = update.getUpdatedTask();
		assertNull(updatedTask.getTaskName());
		testTags(updatedTask.getTags(), "#haha");
		assertNull(updatedTask.getLocation());
		assertNull(updatedTask.getStartDate());
		assertNull(updatedTask.getEndDate());
		
		
		// hybrid - date and tag
		command = Interpreter.getCommand("update d2 #impt 9/11 2pm");
		update = (CommandUpdate) command;
		updatedTask = update.getUpdatedTask();
		assertNull(updatedTask.getTaskName());
		testTags(updatedTask.getTags(), "#impt");
		assertNull(updatedTask.getLocation());
		assertNull(updatedTask.getStartDate());
		testDate(updatedTask.getEndDate(), today.get(Calendar.YEAR), 8, 11, 14,
				0, 0);
		
		// hybrid - date and name
		command = Interpreter.getCommand("update d2 #impt homework");
		update = (CommandUpdate) command;
		updatedTask = update.getUpdatedTask();
		assertEquals("homework", updatedTask.getTaskName());
		testTags(updatedTask.getTags(), "#impt");
		assertNull(updatedTask.getLocation());
		assertNull(updatedTask.getStartDate());
		assertNull(updatedTask.getEndDate());

		// Test 3: case-insensitivity

		// floating task
		command = Interpreter.getCommand("uPdATe D2 @sch go dinner #food");
		assertEquals(Command.UPDATE, command.getCommandType());
		update = (CommandUpdate) command;
		assertEquals("d2", update.getLineCode());
		assertEquals("uPdATe D2 @sch go dinner #food", update.getUserInput());

		updatedTask = update.getUpdatedTask();
		assertEquals("go dinner", updatedTask.getTaskName());
		testTags(updatedTask.getTags(), "#food");
		assertEquals("@sch", updatedTask.getLocation());
		assertNull(updatedTask.getStartDate());
		assertNull(updatedTask.getEndDate());

		// deadline task
		command = Interpreter
				.getCommand("uPdATe F5 @sch go lunch sep 21 #food");
		assertEquals(Command.UPDATE, command.getCommandType());
		update = (CommandUpdate) command;
		assertEquals("f5", update.getLineCode());
		assertEquals("uPdATe F5 @sch go lunch sep 21 #food",
				update.getUserInput());

		updatedTask = update.getUpdatedTask();
		assertEquals("go lunch", updatedTask.getTaskName());
		testTags(updatedTask.getTags(), "#food");
		assertEquals("@sch", updatedTask.getLocation());
		testDate(updatedTask.getEndDate(), today.get(Calendar.YEAR), 8, 21,
				today.get(Calendar.HOUR_OF_DAY), today.get(Calendar.MINUTE),
				today.get(Calendar.SECOND));

		// timed task
		command = Interpreter
				.getCommand("uPdATe T20 @sch go dinner 9pm to 10:30pm");
		assertEquals(Command.UPDATE, command.getCommandType());
		update = (CommandUpdate) command;
		assertEquals("t20", update.getLineCode());
		assertEquals("uPdATe T20 @sch go dinner 9pm to 10:30pm",
				update.getUserInput());

		updatedTask = update.getUpdatedTask();
		assertEquals("go dinner", updatedTask.getTaskName());
		assertEquals("@sch", updatedTask.getLocation());
		testDate(updatedTask.getStartDate(), today.get(Calendar.YEAR),
				today.get(Calendar.MONTH), today.get(Calendar.DATE), 21, 0, 0);
		testDate(updatedTask.getEndDate(), today.get(Calendar.YEAR),
				today.get(Calendar.MONTH), today.get(Calendar.DATE), 22, 30, 0);

		// Test 3: invalid arguments
		command = Interpreter.getCommand("update E3");
		assertEquals(Command.UPDATE, command.getCommandType());
		update = (CommandUpdate) command;
		assertNull(update.getLineCode());
		assertTrue(update.hasMissingArgs());
		assertEquals("update E3", update.getUserInput());

		command = Interpreter.getCommand("update");
		assertEquals(Command.UPDATE, command.getCommandType());
		update = (CommandUpdate) command;
		assertNull(update.getLineCode());
		assertTrue(update.hasMissingArgs());
		assertEquals("update", update.getUserInput());

		command = Interpreter.getCommand("update 3");
		assertEquals(Command.UPDATE, command.getCommandType());
		update = (CommandUpdate) command;
		assertNull(update.getLineCode());
		assertTrue(update.hasMissingArgs());
		assertEquals("update 3", update.getUserInput());

	}

	@Test
	public void testGetCommandView() throws Exception {

		// Test 1: Basic function
		Command command = Interpreter.getCommand("view agenda");
		assertEquals(Command.VIEW, command.getCommandType());
		CommandView view = (CommandView) command;
		assertEquals(UI.AGENDA, view.getViewType());
		assertEquals("view agenda", view.getUserInput());
		assertFalse(view.hasMissingArgs());

		// Test 2: Case insensitivity
		command = Interpreter.getCommand("VIEW Agenda");
		assertEquals(Command.VIEW, command.getCommandType());
		view = (CommandView) command;
		assertEquals(UI.AGENDA, view.getViewType());
		assertEquals("VIEW Agenda", view.getUserInput());
		assertFalse(view.hasMissingArgs());

		// Test 3: invalid argument
		command = Interpreter.getCommand("view agen");
		assertEquals(Command.VIEW, command.getCommandType());
		view = (CommandView) command;
		assertEquals(UI.INVALID, view.getViewType());
		assertEquals("view agen", view.getUserInput());
		assertTrue(view.hasMissingArgs());

		command = Interpreter.getCommand("view");
		assertEquals(Command.VIEW, command.getCommandType());
		view = (CommandView) command;
		assertEquals(UI.INVALID, view.getViewType());
		assertEquals("view", view.getUserInput());
		assertTrue(view.hasMissingArgs());
	}

	@Test
	public void testGetCommandHelp() throws Exception {
		// Test 1: Basic function
		Command command = Interpreter.getCommand("help add");
		assertEquals(Command.HELP, command.getCommandType());
		CommandHelp help = (CommandHelp) command;
		assertEquals(Command.ADD, help.getHelpCommand());
		assertEquals("help add", help.getUserInput());
		assertFalse(help.hasMissingArgs());

		// Test 2: invalid argument
		command = Interpreter.getCommand("help test");
		assertEquals(Command.HELP, command.getCommandType());
		help = (CommandHelp) command;
		assertEquals(null, help.getHelpCommand());
		assertEquals("help test", help.getUserInput());
		assertTrue(help.hasMissingArgs());

	}

	@Test
	public void testGetCommandSearchName() throws Exception {
		// Test 1: Basic function
		Command command = Interpreter.getCommand("search-name hello");
		assertEquals(Command.SEARCH_NAME, command.getCommandType());
		CommandSearchName searchName = (CommandSearchName) command;
		assertEquals("hello", searchName.getSearchString());
		assertEquals("search-name hello", searchName.getUserInput());
		assertFalse(searchName.hasMissingArgs());

		// Test 2: Punctuation, case and spaces
		command = Interpreter.getCommand("search-name hello World!");
		assertEquals(Command.SEARCH_NAME, command.getCommandType());
		searchName = (CommandSearchName) command;
		assertEquals("hello World!", searchName.getSearchString());
		assertEquals("search-name hello World!", searchName.getUserInput());
		assertFalse(searchName.hasMissingArgs());

		// Test 2: invalid argument
		command = Interpreter.getCommand("search-name");
		assertEquals(Command.SEARCH_NAME, command.getCommandType());
		searchName = (CommandSearchName) command;
		assertEquals("search-name", searchName.getUserInput());
		assertTrue(searchName.hasMissingArgs());
	}

	@Test
	public void testGetCommandSearchTime() throws Exception {
		// Test 1: Basic function
		Command command = Interpreter.getCommand("search-time aug 4 to sep 10");
		assertEquals(Command.SEARCH_TIME, command.getCommandType());
		CommandSearchTime searchTime = (CommandSearchTime) command;
		Calendar today = Calendar.getInstance();
		testDate(searchTime.getTimeStart(), today.get(Calendar.YEAR), 7, 4,
				today.get(Calendar.HOUR_OF_DAY), today.get(Calendar.MINUTE),
				today.get(Calendar.SECOND));
		testDate(searchTime.getTimeEnd(), today.get(Calendar.YEAR), 8, 10,
				today.get(Calendar.HOUR_OF_DAY), today.get(Calendar.MINUTE),
				today.get(Calendar.SECOND));
		assertFalse(searchTime.hasMissingArgs());

		// Test 2: Automatically order the time
		command = Interpreter.getCommand("search-time dec 4 to aug 10");
		assertEquals(Command.SEARCH_TIME, command.getCommandType());
		searchTime = (CommandSearchTime) command;
		testDate(searchTime.getTimeStart(), today.get(Calendar.YEAR), 7, 10,
				today.get(Calendar.HOUR_OF_DAY), today.get(Calendar.MINUTE),
				today.get(Calendar.SECOND));
		testDate(searchTime.getTimeEnd(), today.get(Calendar.YEAR), 11, 4,
				today.get(Calendar.HOUR_OF_DAY), today.get(Calendar.MINUTE),
				today.get(Calendar.SECOND));
		assertFalse(searchTime.hasMissingArgs());

		// Test 3: invalid argument
		command = Interpreter.getCommand("search-time hello");
		assertEquals(Command.SEARCH_TIME, command.getCommandType());
		searchTime = (CommandSearchTime) command;
		assertEquals("search-time hello", searchTime.getUserInput());
		assertTrue(searchTime.hasMissingArgs());

		command = Interpreter.getCommand("search-time aug 4");
		assertEquals(Command.SEARCH_TIME, command.getCommandType());
		searchTime = (CommandSearchTime) command;
		assertTrue(searchTime.hasMissingArgs());
	}

}

	// End of segment: D:\everything\eclipseworkspace\ZombieTask\main\src\tests\InterpreterAtd.java





	/**
	 * origin: D:\everything\eclipseworkspace\ZombieTask\main\src\interpreter\CommandView.java
	 */

 *
 */
public class CommandView extends Command {
	FORMAT viewType = null;
	
	/**
	 * Constructor for the View command object. It is initialised with a string
	 * indicating the type of view and a boolean variable to indicate if there
	 * are missing arguments.
	 * @param newViewType the type of view chosen to see tasks
	 * @param userInput the original user input
	 * @param hasMissingArgs boolean variable to indicate missing arguments
	 */
	public CommandView(FORMAT newViewType, String userInput, boolean hasMissingArgs) {
		super(Command.VIEW, userInput, hasMissingArgs);
		viewType = newViewType;
	}
	
	/**
	 * Accessor for view type
	 * @return the type of view chosen to see tasks
	 */
	public FORMAT getViewType() {
		return viewType;
	}
	
}

	// End of segment: D:\everything\eclipseworkspace\ZombieTask\main\src\interpreter\CommandView.java





	/**
	 * origin: D:\everything\eclipseworkspace\ZombieTask\main\src\interpreter\CommandHelp.java
	 */

 *
 */
public class CommandHelp extends Command {
	String helpCommand = null;
	
	/**
	 * Constructor for the Help command object. It is initialised with a string
	 * indicating the command that the user needs help with and a boolean 
	 * variable to indicate if there are missing arguments.
	 * @param newHelpCommand the command that the user needs help with
	 * @param userInput the original user input
	 * @param hasMissingArgs boolean variable to indicate missing arguments
	 */
	public CommandHelp(String newHelpCommand, String userInput, boolean hasMissingArgs) {
		super(Command.HELP, userInput, hasMissingArgs);
		helpCommand = newHelpCommand;
	}
	
	/**
	 * Accessor for help command
	 * @return the command that the user needs help with
	 */
	public String getHelpCommand() {
		return helpCommand;
	}
	
}

	// End of segment: D:\everything\eclipseworkspace\ZombieTask\main\src\interpreter\CommandHelp.java





	/**
	 * origin: D:\everything\eclipseworkspace\ZombieTask\main\src\interpreter\CommandSearchName.java
	 */

 *
 */
public class CommandSearchName extends Command {
	String searchString = null;
	
	/**
	 * Constructor for the Search Name command object. It is initialised with a
	 * search string and a boolean variable to indicate if there are missing
	 * arguments.
	 * @param newSearchString the search string which is used to find a task
	 * @param userInput the original user input
	 * @param hasMissingArgs boolean variable to indicate missing arguments
	 */
	public CommandSearchName(String newSearchString, String userInput, 
			boolean hasMissingArgs) {
		super(Command.SEARCH_NAME, userInput, hasMissingArgs);
		searchString = newSearchString;
	}
	
	/**
	 * Accessor for search string
	 * @return the search string used to find a task
	 */
	public String getSearchString() {
		return searchString;
	}
	
}

	// End of segment: D:\everything\eclipseworkspace\ZombieTask\main\src\interpreter\CommandSearchName.java





	/**
	 * origin: D:\everything\eclipseworkspace\ZombieTask\main\src\interpreter\CommandUpdate.java
	 */

 *
 */
public class CommandUpdate extends Command {
	String lineCode = null;
	CommandAdd updatedTask = null;
	
	/**
	 * Constructor for the Update command object. It is initialised with a line
	 * number and a boolean variable to indicate if there are missing arguments.
	 * @param newLineCode the line code of the task to be updated
	 * @param newUpdatedTask the new task to overwrite updated task
	 * @param hasMissingArgs boolean variable to indicate missing arguments
	 */
	public CommandUpdate(String newLineCode, CommandAdd newUpdatedTask, 
			String userInput, boolean hasMissingArgs) {
		super(Command.UPDATE, userInput, hasMissingArgs);
		lineCode = newLineCode;
		updatedTask = newUpdatedTask;
	}
	
	/**
	 * Accessor for updated task
	 * @return new task for updating
	 */
	public CommandAdd getUpdatedTask() {
		return updatedTask;
	}
	
	/**
	 * Accessor for line code
	 * @return the line code of the task to be updated
	 */
	public String getLineCode() {
		return lineCode;
	}
	
}

	// End of segment: D:\everything\eclipseworkspace\ZombieTask\main\src\interpreter\CommandUpdate.java





	/**
	 * origin: D:\everything\eclipseworkspace\ZombieTask\main\src\interpreter\CommandAdd.java
	 */

 * 
 */

public class CommandAdd extends Command {

	public static String DEFAULT_LOCATION = null; //"none";

	String taskName = null;
	Calendar startDate = null;
	Calendar endDate = null;
	ArrayList<String> tags = null;
	String location = DEFAULT_LOCATION;

	/**
	 * Constructor for the Add command object. It is initialised with a task
	 * name, start date and time, end date and time, a list of tags and a
	 * boolean variable to indicate if there are missing arguments.
	 * 
	 * @param newTaskName the task name of the new add command
	 * @param newStartDate the starting date and time of the task to add
	 * @param newEndDate the ending date and time of the task to add
	 * @param newTags the list of tags associated with the new add command
	 * @param newLocation the location of the new task to add
	 * @param hasMissingArgs boolean variable to indicate missing arguments
	 */
	public CommandAdd(String newTaskName, Calendar newStartDate,
			Calendar newEndDate, ArrayList<String> newTags, String newLocation,
			String userInput, boolean hasMissingArgs) {
		super(Command.ADD, userInput, hasMissingArgs);
		taskName = newTaskName;
		startDate = newStartDate;
		endDate = newEndDate;
		tags = newTags;
		if (newLocation != null) {
			location = newLocation;
		}
	}

	/**
	 * Accessor for task name of the new task
	 * 
	 * @return the name of the task to be added
	 */
	public String getTaskName() {
		return taskName;
	}

	/**
	 * Accessor for starting date and time of the new task
	 * 
	 * @return starting date and time of the task to be added
	 */
	public Calendar getStartDate() {
		return startDate;
	}

	/**
	 * Accessor for ending date and time of the new task
	 * 
	 * @return ending date and time of the task to be added
	 */
	public Calendar getEndDate() {
		return endDate;
	}

	/**
	 * Accessor for tags of the new task
	 * 
	 * @return an arraylist of the tags of the task to be added
	 */
	public ArrayList<String> getTags() {
		return tags;
	}

	/**
	 * Accessor for location of the new task
	 * 
	 * @return a string representing the location
	 */
	public String getLocation() {
		return location;
	}

}

	// End of segment: D:\everything\eclipseworkspace\ZombieTask\main\src\interpreter\CommandAdd.java





	/**
	 * origin: D:\everything\eclipseworkspace\ZombieTask\main\src\interpreter\CommandSearchTime.java
	 */

 *
 */
public class CommandSearchTime extends Command {
	Calendar timeStart = null;
	Calendar timeEnd = null;
	
	/**
	 * Constructor for the Search Time command object. It is initialised with a
	 * search string and a boolean variable to indicate if there are missing
	 * arguments.
	 * @param newTimeStart to find tasks which are later than this time
	 * @param newTimeEnd to find tasks which are earlier than this time
	 * @param userInput the original user input
	 * @param hasMissingArgs boolean variable to indicate missing arguments
	 */
	public CommandSearchTime(Calendar newTimeStart, Calendar newTimeEnd, 
			String userInput, boolean hasMissingArgs) {
		super(Command.SEARCH_TIME, userInput, hasMissingArgs);
		timeStart = newTimeStart;
		timeEnd = newTimeEnd;
	}
	
	/**
	 * Accessor for time start
	 * @return the starting time used to find a task
	 */
	public Calendar getTimeStart() {
		return timeStart;
	}
	
	/**
	 * Accessor for time end
	 * @return the ending time used to find a task
	 */
	public Calendar getTimeEnd() {
		return timeEnd;
	}
	
}

	// End of segment: D:\everything\eclipseworkspace\ZombieTask\main\src\interpreter\CommandSearchTime.java





	/**
	 * origin: D:\everything\eclipseworkspace\ZombieTask\main\src\interpreter\CommandDelete.java
	 */

 *
 */
public class CommandDelete extends Command {
	ArrayList<String> lineCode = null;

	/**
	 * Constructor for the Delete command object. It is initialised with a list
	 * of line codes and a boolean variable to indicate if there are missing
	 * arguments.
	 * 
	 * @param newLineCode the line code of the task to be deleted
	 * @param userInput the original user input
	 * @param hasMissingArgs boolean variable to indicate missing arguments
	 */
	public CommandDelete(ArrayList<String> newLineCode, String userInput,
			boolean hasMissingArgs) {
		super(Command.DELETE, userInput, hasMissingArgs);
		lineCode = newLineCode;
	}

	/**
	 * Accessor for line code
	 * 
	 * @return a list of line codes of the tasks to be deleted
	 */
	public ArrayList<String> getLineCode() {
		return lineCode;
	}

}

	// End of segment: D:\everything\eclipseworkspace\ZombieTask\main\src\interpreter\CommandDelete.java





	/**
	 * origin: D:\everything\eclipseworkspace\ZombieTask\main\src\interpreter\Interpreter.java
	 */

 * 
 */
public class Interpreter {

	public static final int INVALID_NO = -1;
	private static Logger logger = ZombieTask.getLogger();

	/**
	 * Returns the command type based on the first word of the user input
	 * 
	 * @param firstWord the first word of the command from the user
	 * @return the command type, which is the first word in the user input or
	 *         ADD, if the first word is not a valid command
	 */
	public static String getCommandType(String firstWord) {
		if (Command.validCommands.contains(firstWord)) {
			return firstWord;
		} else {
			return Command.ADD;
		}
	}

	/**
	 * Parses the user input and returns a command object containing the command
	 * type and its arguments
	 * 
	 * @param userInput the command from the user
	 * @return a command object with command type and arguments based on the
	 *         command type
	 * @throws NoCommandException for invalid user input, such as null or an
	 *             empty string
	 */
	public static Command getCommand(String userInput)
			throws NoCommandException {
		if (userInput == null || userInput.trim() == "") {
			throw new NoCommandException("No command entered");
		} else {

			String[] userInputTokens = userInput.trim().toLowerCase()
					.split(" ");

			String commandType = getCommandType(userInputTokens[0]);
			logger.log(Level.INFO, "Creating command of type " + commandType);
			switch (commandType) {
				case Command.DELETE:
					if (userInputTokens.length > 1) {
						return getCommandDelete(userInput);
					} else {
						return new CommandDelete(null, userInput, true);
					}
					// Command.DELETE_NAME, Command.DELETE_TIME,
					// Command.DELETE_TAG, Command.DELETE_LOCATION
				case Command.DELETE_NAME:
					if (userInputTokens.length > 1) {
						return getCommandDeleteName(userInput);
					} else {
						return new CommandDeleteName(null, userInput, true);
					}
				case Command.DELETE_TIME:
					if (userInputTokens.length > 1) {
						return getCommandDeleteTime(userInput);
					} else {
						return new CommandDeleteTime(null, null, userInput,
								true);
					}
				case Command.DELETE_TAG:
					if (userInputTokens.length > 1) {
						return getCommandDeleteTag(userInput);
					} else {
						return new CommandDeleteTag(null, userInput, true);
					}
				case Command.DELETE_LOCATION:
					if (userInputTokens.length > 1) {
						return getCommandDeleteLocation(userInput);
					} else {
						return new CommandDeleteLocation(null, userInput, true);
					}
				case Command.UPDATE:
					if (userInputTokens.length > 2) {
						return getCommandUpdate(userInputTokens[1], userInput);
					} else {
						return new CommandUpdate(null, null, userInput, true);
					}
				case Command.VIEW:
					if (userInputTokens.length > 1) {
						return getCommandView(userInputTokens[1], userInput);
					} else {
						return new CommandView(UI.INVALID, userInput, true);
					}
				case Command.HELP:
					if (userInputTokens.length > 1) {
						return getCommandHelp(userInputTokens[1], userInput);
					} else {
						return new CommandHelp(null, userInput, true);
					}
				case Command.DONE:
					if (userInputTokens.length > 1) {
						return getCommandDone(userInput);
					} else {
						return new CommandDone(null, userInput, true);
					}
				case Command.SEARCH_NAME:
					if (userInputTokens.length > 1) {
						return getCommandSearchName(userInput);
					} else {
						return new CommandSearchName(null, userInput, true);
					}
				case Command.SEARCH_TIME:
					if (userInputTokens.length > 1) {
						return getCommandSearchTime(userInput);
					} else {
						return new CommandSearchTime(null, null, userInput,
								true);
					}
				case Command.SEARCH_TAG:
					if (userInputTokens.length > 1) {
						return getCommandSearchTag(userInput);
					} else {
						return new CommandSearchTag(null, userInput, true);
					}
				case Command.SEARCH_LOCATION:
					if (userInputTokens.length > 1) {
						return getCommandSearchLocation(userInput);
					} else {
						return new CommandSearchLocation(null, userInput, true);
					}
				case Command.UNDO:
					return new Command(Command.UNDO, userInput, false);
				case Command.REDO:
					return new Command(Command.REDO, userInput, false);
				case Command.EXIT:
					return new Command(Command.EXIT, userInput, false);
				default:
					return getCommandAdd(userInput);
			}
		}
	}

	private static Command getCommandSearchTime(String userInput) {
		Parser parser = new Parser();
		List<DateGroup> groups = parser.parse(userInput);

		if (groups.isEmpty()) {
			logger.log(Level.INFO, "No date found");
			return new CommandSearchTime(null, null, userInput, true);
		} else {
			// get first date
			Date date1 = groups.get(0).getDates().get(0);
			Date date2 = null;
			Calendar cal1 = Calendar.getInstance();
			cal1.setTime(date1);
			Calendar cal2 = Calendar.getInstance();
			logger.log(Level.INFO, "First date: " + cal1);

			// get second date
			try {
				date2 = groups.get(0).getDates().get(1);
				cal2.setTime(date2);
				logger.log(Level.INFO, "Second date: " + cal1);
			} catch (Exception e) {
				try {
					date2 = groups.get(1).getDates().get(0);
					cal2.setTime(date2);
					logger.log(Level.INFO, "Second date: " + cal1);
				} catch (Exception e1) { // only 1 date
					return new CommandSearchTime(null, null, userInput, true);
				}
			}

			if (cal1.compareTo(cal2) < 0) { // date1 before date2
				return new CommandSearchTime(cal1, cal2, userInput, false);
			}
			return new CommandSearchTime(cal2, cal1, userInput, false);
		}
	}

	private static Command getCommandDeleteTime(String userInput) {
		Parser parser = new Parser();
		List<DateGroup> groups = parser.parse(userInput);

		if (groups.isEmpty()) {
			logger.log(Level.INFO, "No date found");
			return new CommandDeleteTime(null, null, userInput, true);
		} else {
			// get first date
			Date date1 = groups.get(0).getDates().get(0);
			Date date2 = null;
			Calendar cal1 = Calendar.getInstance();
			cal1.setTime(date1);
			Calendar cal2 = Calendar.getInstance();
			logger.log(Level.INFO, "First date: " + cal1);

			// get second date
			try {
				date2 = groups.get(0).getDates().get(1);
				cal2.setTime(date2);
				logger.log(Level.INFO, "Second date: " + cal1);
			} catch (Exception e) {
				try {
					date2 = groups.get(1).getDates().get(0);
					cal2.setTime(date2);
					logger.log(Level.INFO, "Second date: " + cal1);
				} catch (Exception e1) { // only 1 date
					return new CommandDeleteTime(null, null, userInput, true);
				}
			}

			if (cal1.compareTo(cal2) < 0) { // date1 before date2
				return new CommandDeleteTime(cal1, cal2, userInput, false);
			}
			return new CommandDeleteTime(cal2, cal1, userInput, false);
		}
	}

	/**
	 * Creates a CommandSearch name object based on user input
	 * 
	 * @param searchString the string used to search for task
	 * @param userInput the original user input
	 * @return a CommandSearch object with a search string, the original input
	 *         and a boolean value to indicate missing arguments
	 */
	private static Command getCommandSearchName(String userInput) {
		String searchString = userInput.replaceFirst(Command.SEARCH_NAME + " ",
				"");
		return new CommandSearchName(searchString, userInput, false);
	}

	private static Command getCommandDeleteName(String userInput) {
		String searchString = userInput.replaceFirst(Command.DELETE_NAME + " ",
				"");
		return new CommandDeleteName(searchString, userInput, false);
	}

	private static Command getCommandSearchTag(String userInput) {
		String searchString = userInput.replaceFirst(Command.SEARCH_TAG + " ",
				"");
		return new CommandSearchTag(searchString, userInput, false);
	}

	private static Command getCommandDeleteTag(String userInput) {
		String searchString = userInput.replaceFirst(Command.DELETE_TAG + " ",
				"");
		return new CommandDeleteTag(searchString, userInput, false);
	}

	private static Command getCommandSearchLocation(String userInput) {
		String searchString = userInput.replaceFirst(Command.SEARCH_LOCATION
				+ " ", "");
		return new CommandSearchLocation(searchString, userInput, false);
	}

	private static Command getCommandDeleteLocation(String userInput) {
		String searchString = userInput.replaceFirst(Command.DELETE_LOCATION
				+ " ", "");
		return new CommandDeleteLocation(searchString, userInput, false);
	}

	/**
	 * Creates a CommandView object based on user input
	 * 
	 * @param secondWord the second word from the user input
	 * @param userInput the original user input
	 * @return a CommandView object with the view format, the original input and
	 *         a boolean value to indicate missing arguments
	 */
	private static Command getCommandView(String secondWord, String userInput) {
		secondWord = secondWord.toLowerCase().trim();
		FORMAT viewType = UI.getFormat(secondWord);
		if (viewType == UI.INVALID) {
			return new CommandView(viewType, userInput, true);
		}
		return new CommandView(viewType, userInput, false);
	}

	/**
	 * Creates a CommandHelp object based on user input
	 * 
	 * @param secondWord the second word from the user input
	 * @param userInput the original user input
	 * @return a CommandHelp object with the command that the user needs help
	 *         with, the original input and a boolean value to indicate missing
	 *         arguments
	 */
	private static Command getCommandHelp(String secondWord, String userInput) {
		if (Command.validCommands.contains(secondWord)) {
			return new CommandHelp(secondWord, userInput, false);
		} else {
			return new CommandHelp(null, userInput, true);
		}
	}

	/**
	 * Returns tags from contained in the command entered by the user
	 * 
	 * @param userInputWords an array of words entered by the user
	 * @return an arraylist of the tags contained in the command
	 */
	private static ArrayList<String> getTags(String[] userInputWords) {
		ArrayList<String> tags = new ArrayList<String>();
		for (String word : userInputWords) {
			word = word.trim();
			if (word.length() > 1 && word.charAt(0) == '#') {
				tags.add(word);
			}
			logger.log(Level.INFO, "Tags: " + tags.toString());
		}
		return tags;
	}

	private static String getLocation(String[] userInputWords) {

		for (String word : userInputWords) {
			word = word.trim();
			if (word.length() > 1 && word.charAt(0) == '@') {
				return word;
			}
		}

		return null;
	}

	/**
	 * Returns task name by removing time-related keywords and tags from the
	 * user input
	 * 
	 * @param userInput the command entered by the user
	 * @param tags a list of tags parsed from user input
	 * @return the task name, or a description of the task
	 */
	private static String getTaskName(String userInput, List<DateGroup> groups,
			ArrayList<String> tags, String location) {

		// remove location
		if (location != null) {
			userInput = userInput.replace(location, "");
		}

		// get and remove first time-related keyword

		String dateKeywords = null;

		if (groups.isEmpty()) {
			dateKeywords = "";
		} else {
			dateKeywords = groups.get(0).getText();
		}

		if (dateKeywords != null && !dateKeywords.isEmpty()) {
			// search second word onwards for date keyword
			String userInputTemp = userInput.replaceFirst("\\b" + dateKeywords,
					"");
			if (userInputTemp.equals(userInput)) {
				// no date keywords removed, so search start of string
				userInputTemp = userInput.replaceFirst("^" + dateKeywords, "");
			}
			userInput = userInputTemp;
		}

		logger.log(Level.INFO, "Task name: " + userInput);

		// remove tags
		for (String tag : tags) {
			userInput = userInput.replaceAll(tag + " ", "");
			userInput = userInput.replaceAll(" " + tag, "");
			userInput = userInput.replaceAll(tag, "");
		}

		logger.log(Level.INFO, "Task name: " + userInput);

		// remove escape characters
		userInput = userInput.replaceAll("\"", "");

		if (userInput.trim().equals("")) {
			return null;
		}

		return userInput.trim();

	}

	/**
	 * Creates a CommandAdd or CommandAddFloating or CommandAddTimed object from
	 * user input
	 * 
	 * @return a CommandAdd or CommandAddFloating or CommandAddTimed object
	 *         which contains task name, date and time, a list of tags, the
	 *         original input and a boolean variable to indicate missing
	 *         arguments
	 */
	private static Command getCommandAdd(String userInput) {

		ArrayList<String> tags = new ArrayList<String>();
		String location = null;
		String taskName = null;
		String[] userInputWords = userInput.trim().split(" ");

		// remove escaped numbers and words - in quotations
		String userInputTemp = userInput.replaceAll("\"(.*)\"", "");

		// remove location keyword
		userInputTemp = userInputTemp.replaceAll("@[\\S]+[ ]*", "");

		// remove tags
		userInputTemp = userInputTemp.replaceAll("#[\\S]+[ ]*", "");

		// get dates
		Parser parser = new Parser();
		List<DateGroup> groups = parser.parse(userInputTemp);

		tags = getTags(userInputWords);
		location = getLocation(userInputWords);

		// remove leading and trailing spaces, remove add command
		userInputTemp = userInput.trim();
		if (userInputWords[0].toLowerCase().equals(Command.ADD)) {
			userInputTemp = userInputTemp.substring(4);
		}

		if (groups.isEmpty()) { // floating task
			taskName = getTaskName(userInputTemp, groups, tags, location);
			return new CommandAdd(taskName, null, null, tags, location,
					userInput, taskName == null);
		} else {
			// get first date
			Date date1 = groups.get(0).getDates().get(0);
			assert date1 != null;

			Date date2 = null;
			Calendar cal1 = Calendar.getInstance();
			cal1.setTime(date1);
			Calendar cal2 = Calendar.getInstance();

			// get second date
			try {
				date2 = groups.get(0).getDates().get(1);
				cal2.setTime(date2);

			} catch (Exception e) {
				try {
					date2 = groups.get(1).getDates().get(0);
					cal2.setTime(date2);
				} catch (Exception e1) { // only 1 date: deadline task
					taskName = getTaskName(userInputTemp, groups, tags,
							location);

					return new CommandAdd(taskName, null, cal1, tags, location,
							userInput, taskName == null);
				}
			}

			// this removes the first 2 time-related keywords
			taskName = getTaskName(userInputTemp, groups, tags, location);
			
			// handle case when taskName == null
			
			if (taskName != null){
				ArrayList<String> tagsTemp = new ArrayList<String>();
				taskName = getTaskName(taskName, groups, tagsTemp, location);
			}
			
			if (cal1.compareTo(cal2) < 0) { // date1 before date2
				return new CommandAdd(taskName, cal1, cal2, tags, location,
						userInput, taskName == null);
			}
			return new CommandAdd(taskName, cal2, cal1, tags, location,
					userInput, taskName == null);
		}

	}

	/**
	 * Creates a CommandUpdate object from user input
	 * 
	 * @param secondWord the second word of the user input
	 * @return a CommandUpdate object with integer value of line number, the
	 *         original input and a boolean value to indicate missing arguments
	 * @throws Exception for invalid line number or date
	 */
	private static CommandUpdate getCommandUpdate(String secondWord,
			String userInput) {
		try {
			String lineCode = null;
			secondWord = secondWord.toLowerCase();
			boolean validSecondWord = secondWord.matches("[fdt][0-9]+");

			if (validSecondWord) {
				lineCode = secondWord;
				// get third word onwards to parse as an add command

				int spaceIndex = userInput.indexOf(" ");
				String userInputTemp = userInput.substring(spaceIndex + 1);
				spaceIndex = userInputTemp.indexOf(" ");
				userInputTemp = userInputTemp.substring(spaceIndex + 1);
				System.out.println("WTF2! ");
				CommandAdd updatedTask = (CommandAdd) getCommandAdd(userInputTemp);

				return new CommandUpdate(lineCode, updatedTask, userInput,
						false);
			} else {
				return new CommandUpdate(null, null, userInput, true);
			}

		} catch (Exception e) { // invalid date
			return new CommandUpdate(null, null, userInput, true);
		}
	}

	/**
	 * Creates a CommandDone object from user input
	 * 
	 * @param secondWord the second word of the user input
	 * @param userInput the userinput String
	 * @return a CommandDone object with integer value of line number, the
	 *         original input and a boolean value to indicate missing arguments
	 * @throws Exception for invalid line number or date
	 */

	private static CommandDone getCommandDone(String userInput) {
		ArrayList<String> lineCodes = new ArrayList<String>();
		String userInputTemp = userInput.toLowerCase().replaceFirst(
				Command.DONE + " ", "");
		String[] lineCodesTemp = userInputTemp.split(" ");

		// check whether a range is specified
		if (lineCodesTemp[0].matches("[fdt][0-9]+-[0-9]+")) {
			lineCodesTemp = lineCodesTemp[0].split("-");

			String firstChar = Character.toString(lineCodesTemp[0].charAt(0));
			ArrayList<Integer> indices = new ArrayList<Integer>();
			indices.add(Integer.parseInt(lineCodesTemp[0].substring(1)));
			indices.add(Integer.parseInt(lineCodesTemp[1]));

			Collections.sort(indices);
			for (int i = indices.get(0); i <= indices.get(1); i++) {
				lineCodes.add((firstChar + i));
			}
		} else {
			for (String lineCode : lineCodesTemp) {
				if (lineCode.trim().matches("[fdt][0-9]+")) {
					lineCodes.add(lineCode);
				}
			}
		}
		if (lineCodes.isEmpty()) {
			return new CommandDone(null, userInput, true);
		}
		return new CommandDone(lineCodes, userInput, false);
	}

	/**
	 * Creates a CommandDelete object from user input
	 * 
	 * @param secondWord the second word of the user input
	 * @return a CommandDelete object with a list of line codes, the original
	 *         input and a boolean value to indicate missing arguments
	 */
	private static CommandDelete getCommandDelete(String userInput) {
		ArrayList<String> lineCodes = new ArrayList<String>();
		String userInputTemp = userInput.toLowerCase().replaceFirst(
				Command.DELETE + " ", "");
		String[] lineCodesTemp = userInputTemp.split(" ");

		// check whether a range is specified
		if (lineCodesTemp[0].matches("[fdt][0-9]+-[0-9]+")) {
			lineCodesTemp = lineCodesTemp[0].split("-");

			String firstChar = Character.toString(lineCodesTemp[0].charAt(0));
			ArrayList<Integer> indices = new ArrayList<Integer>();
			indices.add(Integer.parseInt(lineCodesTemp[0].substring(1)));
			indices.add(Integer.parseInt(lineCodesTemp[1]));

			Collections.sort(indices);
			for (int i = indices.get(0); i <= indices.get(1); i++) {
				lineCodes.add((firstChar + i));
			}
		} else {
			for (String lineCode : lineCodesTemp) {
				if (lineCode.trim().matches("[fdt][0-9]+")) {
					lineCodes.add(lineCode);
				}
			}
		}
		if (lineCodes.isEmpty()) {
			return new CommandDelete(null, userInput, true);
		}
		return new CommandDelete(lineCodes, userInput, false);

	}
}

	// End of segment: D:\everything\eclipseworkspace\ZombieTask\main\src\interpreter\Interpreter.java





	/**
	 * origin: D:\everything\eclipseworkspace\ZombieTask\main\src\interpreter\Command.java
	 */

 * 
 */
public class Command {

	// static command types
	public static final String ADD = "add";
	public static final String DELETE = "delete";
	public static final String DELETE_NAME = "delete-name";
	public static final String DELETE_TIME = "delete-time";
	public static final String DELETE_TAG = "delete-tag";
	public static final String DELETE_LOCATION = "delete-location";
	public static final String UPDATE = "update";
	public static final String VIEW = "view";
	public static final String UNDO = "undo";
	public static final String REDO = "redo";
	public static final String HELP = "help";
	public static final String DONE = "done";
	public static final String SEARCH = "search";
	public static final String SEARCH_NAME = "search-name";
	public static final String SEARCH_TIME = "search-time";
	public static final String SEARCH_TAG = "search-tag";
	public static final String SEARCH_LOCATION = "search-location";
	public static final String EXIT = "exit";

	// list for ease of checking valid commands
	public static List<String> validCommands = Arrays.asList(Command.ADD,
			Command.DELETE, Command.DELETE_NAME, Command.DELETE_TIME, Command.DELETE_TAG,
			Command.DELETE_LOCATION, Command.UPDATE, Command.VIEW, Command.UNDO,
			Command.REDO, Command.HELP, Command.DONE, Command.SEARCH, Command.SEARCH_NAME,
			Command.SEARCH_TIME, Command.SEARCH_TAG, Command.SEARCH_LOCATION, Command.EXIT);

	String commandType = null;
	String userInput = null;
	boolean hasMissingArgs = false;

	/**
	 * Constructor for command object. It is initialised with a string
	 * indicating the command type
	 * 
	 * @param newCommandType the type of command
	 * @param newUserInput the original user input
	 * @param newHasMissingArgs whether the user input has missing arguments
	 */
	public Command(String newCommandType, String newUserInput,
			boolean newHasMissingArgs) {
		commandType = newCommandType;
		userInput = newUserInput;
		hasMissingArgs = newHasMissingArgs;
	}

	/**
	 * Accessor for the type of command, which can be Add, Delete, Update, View
	 * or Undo.
	 * 
	 * @return commandType the type of command
	 */
	public String getCommandType() {
		return commandType;
	}

	/**
	 * Accessor for user input
	 * 
	 * @return the original user input for this command
	 */
	public String getUserInput() {
		return userInput;
	}

	/**
	 * Accessor for missing arguments
	 * 
	 * @return a boolean variable indicating if arguments are missing
	 */
	public boolean hasMissingArgs() {
		return hasMissingArgs;
	}

}

	// End of segment: D:\everything\eclipseworkspace\ZombieTask\main\src\interpreter\Command.java





	/**
	 * origin: D:\everything\eclipseworkspace\ZombieTask\main\src\exception\NoCommandException.java
	 */

 *
 */
public class NoCommandException extends Exception {
	public NoCommandException(String msg) {
		super(msg);
	}
}

	// End of segment: D:\everything\eclipseworkspace\ZombieTask\main\src\exception\NoCommandException.java





